# Аннотация

Лабораторная работа БЕЗ вариантов. Необходимо выполнить ВСЕ задания в одном проекте. В классах<br>
могут присутствовать методы со спецификатором доступа private вспомогательного характера.<br>
Организовать проверку входных данных. К каждому классу и методу написать xml-документацию.<br>
Каждая задача оценивается по 3 балла, xml-документация оценивается в 2 балла. Максимально за<br>
лабораторную работу можно получить 10 баллов (8 баллов за решение задач + 2 балла за оформление<br>
отчета). За решение с использованием шаблонов можно получить дополнительные 5 баллов, которые<br>
можно добавить к любой контрольной точке.


# Задание 1. Кот

## Формулировка

### 1 Кот мяукает.
Создайте сущность Кот, которая описывается следующим образом:<br>
- Имеет Имя (строка)
- Для создания необходимо указать имя кота.
- Может быть приведен к текстовой форме вида: “кот: Имя”
- Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
- Может помяукать N раз, что приводит к выводу на экран следующего текста: “Имя: мяумяу-…-мяу!”, где количество “мяу”равно N.
Создайте кота по имени “Барсик”, и затем пусть он помяукает сначала один раз, а затем три раза.<br>


### 2 Интерфейс Мяуканье.
Разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у<br>
каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:<br>
public void meow();<br>
Дополните решение предыдущей задачи так, чтобы иметь возможность передать Кота в написанный<br>
вами метод и протестируйте работоспособность решения передав в него нескольких котов, а также<br>
создайте любой другой произвольный класс и передайте в написанный метод его объекты.<br>

### 3 Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из предыдущего<br>
задания. Необходимо таким образом передать кота в указанный метод, что бы после окончания его<br>
работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед<br>
вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы<br>
выводим количество мяуканий на экран. Кота изменять нельзя.<br>
<img width="600" height="500" alt="ex_count_meow" src="https://github.com/Nikita5283/l6/blob/main/ex_count_meow.png" /><br>

## Алгоритм решения

### 1. Создание интерфейса

- Создать интерфейс IMeowable.
- Объявить в нем единственный метод void Meow().


### 2. Реализация сущности кот

1. Создать класс Cat, который реализует интерфейс IMeowable.
1. Реализовать Инкапсуляцию (Свойство Name):
1. Создать приватное поле для имени.
1. Создать публичное свойство.
1. В сеттере (set) добавить условие: если (value пустое) { имя = "Барсик" } иначе { имя = value }.
1. Реализовать метод ToString():
1. Переопределить стандартный метод (override).
1. Вернуть строку формата "кот: Имя".
1. Реализовать методы мяуканья:
    1. Meow() (из интерфейса): вывести в консоль "Имя: мяу!".
    1. Meow(int n) (перегрузка):
        1. Проверить, что n > 0.
        1. Сформировать строку.
        1. Вывести итоговую строку.

### 3. Задание 2 — Метод для всех

1. Создать вспомогательный класс Funs (или MeowService).
1. Написать статический метод MeowsCare:
    1. В качестве аргумента метод должен принимать коллекцию интерфейсов: IEnumerable<IMeowable> objects.
    1. Суть: Метод не должен знать, что к нему пришли именно коты. Ему достаточно знать, что объекты умеют мяукать.
    1. Реализовать цикл:
        1. Пройти циклом foreach по коллекции.
        1. У каждого элемента вызвать метод .Meow().
        1. Для проверки Задания 3 сделаем цикл внутри цикла, чтобы каждый объект мяукнул несколько раз.

### 4. Реализация подсчета через Декоратор (Задание 3)

1. Создать класс MeowableCounter, реализующий IMeowable (это важно, чтобы он мог маскироваться под кота).
1. Создать поле-жертву: приватное поле типа IMeowable (сюда мы спрячем настоящего кота).
1. Добавить поле-счетчик: Целочисленная переменная MeowCount, изначально 0.
1. Написать конструктор: Принимает IMeowable и сохраняет его в поле-жертву.
1. Реализовать метод Meow():
    1. Вызвать .Meow() у спрятанного объекта (делегирование выполнения).
    1. Увеличить счетчик MeowCount на 1.


### 5. Сборка и тестирование (Main)

1. Тест Кота:
    1. Создать кота new Cat(null) -> убедиться, что он стал "Барсиком".
    1. Вызвать Meow(3).
1. Тест Полиморфизма:
    1. Создать список List<IMeowable>.
    1. Положить туда Кота и (опционально) другой класс, реализующий интерфейс.
    1. Передать список в метод Funs.MeowsCare.
1. Тест Декоратора:
    1. Создать нового кота.
    1. Создать объект-счетчик, передав ему этого кота: var counter = new MeowableCounter(cat);.
    1. Передать счетчик (а не кота!) в метод Funs.MeowsCare.
    1. После выполнения метода вывести значение counter.MeowCount.


## Тесты

### Тест кота

<img width="600" height="500" alt="test_cat" src="https://github.com/Nikita5283/l6/blob/main/test_cat.png" /><br>

### Тест полиморфизма

<img width="300" height="400" alt="test_pol" src="https://github.com/Nikita5283/l6/blob/main/test_pol.png" /><br>

### Тест декоратора

<img width="400" height="300" alt="test_dec" src="https://github.com/Nikita5283/l6/blob/main/test_dec.png" /><br>

# Задание 2. Дроби

## Формулировка

### 1 Дроби.

Создайте сущность Дробь со следующими особенностями:<br>
- Имеет числитель: целое число
- Имеет знаменатель: целое число
- Дробь может быть создана с указанием числителя и знаменателя
- Может вернуть строковое представление вида “числитель/знаменатель”
- Может выполнять операции сложения, вычитания, умножения и деления с другой
Дробью или целым числом. Результатом операции должна быть новая Дробь <br>
(таким образом, обе исходные дроби не изменяются) (Обязательно использовать перегрузки!)<br>
- Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.


Затем необходимо выполнить следующие задачи:
1. Создать несколько экземпляров дробей.
2. Написать по одному примеру использования каждого метода.
3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9»
4. Посчитать f1.sum(f2).div(f3).minus(5)

### 2 Сравнение дробей.

Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби<br>
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

### 3 Клонирование дроби. Интерфейс ICloneable.

Переопределите метод клонирования, таким образом, чтобы при его вызове возвращался новый<br>
объект Дроби, значения полей которого будут копиями оригинальной Дроби.<br>

### 4 В класс Интерфейс дроби
Добавить интерфейс на два метода:
- получение вещественного значения
- установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.

## Алгоритм решения


### 1. Метод для нахождения НОД

1.  Реализовать метод Евклида для поиска Наибольшего Общего Делителя.
    *   *Зачем:* Чтобы `2/4` сразу превращалось в `1/2`.
    *   *Логика:* `пока b != 0: temp = b; b = a % b; a = temp; вернуть a`.

### 2. Базовый класс `Fraction`

1.  **Поля:** Определить два `protected` или `private` поля: `_numerator` (числитель) и `_denominator` (знаменатель). Добавить свойства (геттеры) для чтения.
2.  **Конструктор:**
    *   Принять `numerator` и `denominator`.
    *   **Проверка:** Если `denominator == 0`, выбросить ошибку (`Exception`).
    *   **Нормализация знака:** Если `den < 0`, инвертировать знак у обоих чисел (чтобы минус всегда был вверху).
    *   **Сокращение:** Найти НОД и поделить на него оба числа.
    *   Сохранить результаты в поля.
3.  **Вывод (`ToString`):** Переопределить метод для возврата строки вида `"число/число"`.

### 3. Арифметика и Операторы

1.  **Перегрузка операторов (`+`, `-`, `*`, `/`):**
    Для каждой операции использовать математические формулы дробей (например, сложение через общий знаменатель).
2.  **Перегрузка с числом:** Добавить версии операторов, где второй аргумент — `int` (превращая его в `int/1`).
3.  **Методы-обертки:**
    *   Реализовать методы `Sum`, `Minus`, `Div`, `Mult`.
    *   Внутри они просто вызывают написанные выше операторы (`return this + other`).

### 4. Сравнение объектов
1.  **Переопределение `Equals`:**
    *   Проверить, что пришедший объект — это `Fraction`.
    *   Сравнить `this.Numerator` с `other.Numerator` и `this.Denominator` с `other.Denominator`.
2.  **Переопределение `GetHashCode`:**
    *   Сгенерировать хэш на основе полей (обязательно, если переопределен `Equals`).

### 5. Клонирование
1.  **Интерфейс `ICloneable`:** Добавить его в заголовок класса (`class Fraction : ICloneable`).
2.  **Метод `Clone`:**
    *   Вернуть `new Fraction(this.numerator, this.denominator)`.
    *   Это создаст полную независимую копию.

### 6. Умное кэширование

1.  **Интерфейс `IFractionManagement`:**
    *   Описать методы: `double GetRealValue()`, `void SetNumerator(int)`, `void SetDenominator(int)`.
    *   Внедрить этот интерфейс в базовый класс `Fraction`.
2.  **Наследник `CachedFraction`:**
    *   Создать класс, наследующий `Fraction`.
    *   Добавить поле `private double? _cache` (обнуляемое). Изначально `null`.
3.  **Реализация `GetRealValue` (в наследнике):**
    *   Проверка: Если `_cache != null` -> вернуть `_cache`.
    *   Иначе: Вычислить `(double)num / den`, записать в `_cache`, вернуть результат.
4.  **Реализация Сеттеров (SetNumerator/SetDenominator):**
    *   Вызвать базовую логику изменения числа.
    *   **Сброс:** Присвоить `_cache = null`.
    *   *Логика:* Если данные изменились, старый кэш надо удалить.

### 7. Сборка (Main)
В методе `Main` последовательно протестировать все этапы:
1.  Создать дроби (в том числе отрицательные и несокращенные).
2.  Вывести примеры арифметики.
3.  Проверить цепочку методов `.Sum().Div()`.
4.  Сравнить дроби через `Equals`.
5.  Создать `CachedFraction`, вызвать получение значения два раза и убедиться, что второй раз вычисления не было.

## Тесты

### Тест операций

<img width="400" height="300" alt="test_operations" src="https://github.com/Nikita5283/l6/blob/main/test_operations.png" /><br>

### Тест сравнения

<img width="400" height="300" alt="test_comparison" src="https://github.com/Nikita5283/l6/blob/main/test_comparison.png" /><br>

### Тест клонирования

<img width="400" height="300" alt="test_copy" src="https://github.com/Nikita5283/l6/blob/main/test_copy.png" /><br>

### Тест кэширования

<img width="400" height="300" alt="test_cash" src="https://github.com/Nikita5283/l6/blob/main/test_cash.png" /><br>

